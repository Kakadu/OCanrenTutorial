\section{Specification in \textsc{Coq}}
\label{specification}

We certified all the definitions and propositions from the previous sections using \textsc{Coq} proof assistant. The \textsc{Coq} specification for the most parts closely follows the formal descriptions we gave by means of inductive definitions (and inductively defined propositions in particular) and structural induction in proofs. The detailed description of the specification, including code snippets, is provided in the Appendix~\ref{appendix_coq}, and in this section we adress only some non-trivial parts of it and some design choices.

The language formalized in \textsc{Coq} has a few non-essential simplifications for the sake of convenience. Specifically, we restrict the arities of all constructors to be either zero or two and require all relations to have exactly one argument. These restrictions do not make the language less expressive in any way since we can always represent a sequence of terms as a list using constructors \lstinline|Nil$^0$| and \lstinline|Cons$^2$|. 

In our formalization of the language we use higher-order abstract syntax~\cite{HOAS} for variable binding, therefore we work explicitly only with semantic variables. We preferred it to the first-order syntax because it gives us the ability to use substitution and the induction principle provided by \textsc{Coq}. On the other hand, we need to explicitly specify a requirement on the syntax representation, which is trivially fulfilled in the first-order case: all bindings have to be ``consistent'', i.e. if we instantiate a higher-order \lstinline|fresh| construct with different semantic variables the results will be the same up to some renaming (provided that both those variables are not free in the body of the binder). Another requirement we have to specify explicitly (independent of HOAS/FOAS dichotomy) is a requirement that the definitions of relations do not contain unbound semantic variables.

To formalize the operational part in \textsc{Coq} we first need to define all preliminary notions from unification theory~\cite{Unification} which our semantics uses. In particular, we need to implement the notion of the most general unifier (MGU). As it is well-known~\cite{StructuralMGU} all standard recursive algorithms for calculating MGU are not decreasing on argument terms, so we can't define them as simple recursive functions in \textsc{Coq} due to the termination check failure. The standard approach to tackle this problem is to define the function through well-founded recursion. We use a distinctive version of this approach, which is more convenient for our purposes: we define MGU as a proposition (for which do not have the termination requirement in \textsc{Coq}) with a dedicated structurally-recursive function for one step of unification, and then we use a well-founded induction to prove the existence of a corresponding result for any arguments and defining properties of MGU. For this well-founded induction, we use the number of distinct free variables in argument terms as a well-founded order on pairs of terms.

In operational semantics, to define traces as (possibly) infinite sequences of transitions we use the standard approach in \textsc{Coq}~--- coinductively defined streams. Operating with them requires a number of well-known tricks, described in~\cite{CPDT}, to be applied, such as the use of a separate coinductive definition of equality on streams.

The final proofs of soundness and completeness of operational semantics are relatively small, but the large amount of work is hidden in the proofs of auxiliary facts that they use (including lemmas from the previous sections and some technical machinery for handling representing functions).
