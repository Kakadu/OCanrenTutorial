open OCanren;;

module ASCII_Ctrl = struct      
  @type t = NUL (** Null *)
          | SOH (** Start of heading *)
          | STX (** Start of text *)
          | ETX (** End of text *)
          | EOT (** End of transmission *)
          | ENQ (** Enquiry *)
          | ACK (** Ackonwledge *)
          | BEL (** Bell *)
          | BS  (** Back space *)
          | HT  (** Horizontal tab *)
          | LF  (** Line Feed *)
          | VT  (** Vertical tab *)
          | FF  (** Form feed *)
          | CR  (** Carriage return *)
          | SO  (** Shift out *)
          | SI  (** Shift in *)
          | DLE (** Data line escape *)
          | DC1 (** Device control 1 *)
          | DC2 (** Device control 2 *)
          | DC3 (** Device control 3 *)
          | DC4 (** Device control 4 *)
          | NAK (** Negative ack. *)
          | SYN (** Synchronous idle *)
          | ETB (** End of block *)
          | CAN (** Cancel *)
          | EM  (** End of medium *)
          | SUB (** Substitute *)
          | ESC (** Escape *)
          | FS  (** File separator *)
          | GS  (** Group separator *)
          | RS  (** Record separator*)
          | US  (** Unit separator *)
  with show;;
  @type ground = t with show;;
  @type logic = t Logic.logic   with show;;
  type groundi = (ground, logic) injected;;
  
  (** entries of [Inj] is generated by [noCanren] *)
  module Inj = struct  
    let nUL () = !! NUL
    let sOH () = !! SOH
    let sTX () = !! STX
    let eTX () = !! ETX
    let eOT () = !! EOT
    let eNQ () = !! ENQ
    let aCK () = !! ACK
    let bEL () = !! BEL
    let bS () = !! BS
    let hT () = !! HT
    let lF () = !! LF
    let vT () = !! VT
    let fF () = !! FF
    let cR () = !! CR
    let sO () = !! SO
    let sI () = !! SI
    let dLE () = !! DLE
    let dC1 () = !! DC1
    let dC2 () = !! DC2
    let dC3 () = !! DC3
    let dC4 () = !! DC4
    let nAK () = !! NAK
    let sYN () = !! SYN
    let eTB () = !! ETB
    let cAN () = !! CAN
    let eM () = !! EM
    let sUB () = !! SUB
    let eSC () = !! ESC
    let fS () = !! FS
    let gS () = !! GS
    let rS () = !! RS
    let uS () = !! US
  end;;
end;;

module LString = struct
  @type t = GT.string with show;;
  @type ground = t with show;;
  @type logic = t Logic.logic with show;;
  type groundi = (ground, logic) injected;;
end;;

(* https://www.gnu.org/software/emacs/manual/html_node/emacs/Replace.html#Replace *)

let ascii_ctrl :
      ASCII_Ctrl.groundi -> Std.Nat.groundi -> LString.groundi -> goal
  = fun c n s ->
  let open ASCII_Ctrl.Inj in
  ocanren{ c == NUL & n == 0 & s == "Null"
         | c == SOH & n == 1 & s == "Start of heading"
         | c == STX (** Start of text *)
         | c == ETX (** End of text *)
         | c == EOT (** End of transmission *)
         | c == ENQ (** Enquiry *)
         | c == ACK (** Ackonwledge *)
         | c == BEL (** Bell *)
         | c == BS  (** Back space *)
         | c == HT  (** Horizontal tab *)
         | c == LF  (** Line Feed *)
         | c == VT  (** Vertical tab *)
         | c == FF  (** Form feed *)
         | c == CR  (** Carriage return *)
         | c == SO  (** Shift out *)
         | c == SI  (** Shift in *)
         | c == DLE (** Data line escape *)
         | c == DC1 (** Device control 1 *)
         | c == DC2 (** Device control 2 *)
         | c == DC3 (** Device control 3 *)
         | c == DC4 (** Device control 4 *)
         | c == NAK (** Negative ack. *)
         | c == SYN (** Synchronous idle *)
         | c == ETB (** End of block *)
         | c == CAN (** Cancel *)
         | c == EM  (** End of medium *)
         | c == SUB (** Substitute *)
         | c == ESC (** Escape *)
         | c == FS  (** File separator *)
         | c == GS  (** Group separator *)
         | c == RS  (** Record separator*)
         | c == US  (** Unit separator *)};;

(*
Printf.printf "Session 1:\n\n";;

let _ =
  List.iter print_endline @@
    Stream.take ~n:1 @@
      run q (fun s -> phrase_code s c_g) project;;

 *)
